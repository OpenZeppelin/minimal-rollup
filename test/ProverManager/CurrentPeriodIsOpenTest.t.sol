// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {CurrentPeriodIsActiveTest} from "./CurrentPeriodIsActiveTest.t.sol";

import {LibPercentage} from "src/libs/LibPercentage.sol";
import {LibProvingPeriod} from "src/libs/LibProvingPeriod.sol";
import {BaseProverManager} from "src/protocol/BaseProverManager.sol";
import {IProverManager} from "src/protocol/IProverManager.sol";

/// Represents states where the current period has no end timestamp
abstract contract CurrentPeriodIsOpenTest is CurrentPeriodIsActiveTest {
    function test_CurrentPeriodIsOpen_bid_shouldRevertIfOfferMatchesFee() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());

        vm.prank(proverA);
        vm.expectRevert(BaseProverManager.OfferedFeeTooHigh.selector);
        proverManager.bid(period.fee);
    }

    function test_CurrentPeriodIsOpen_bid_shouldRevertIfOfferInsufficientlyUnderbid() public {
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        if (period.fee == 0) {
            // ignore this test if the fee is already zero
            return;
        }

        _deposit(proverA, DEPOSIT_AMOUNT);
        vm.prank(proverA);
        vm.expectRevert(BaseProverManager.OfferedFeeTooHigh.selector);
        proverManager.bid(period.fee - 1);
    }

    function test_CurrentPeriodIsOpen_bid_shouldNotChangeCurrentPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 initialPeriodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(initialPeriodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        assertEq(proverManager.currentPeriodId(), initialPeriodId, "Current period was changed");
    }

    function test_CurrentPeriodIsOpen_bid_shouldCloseCurrentPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory periodBefore = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(periodBefore.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        LibProvingPeriod.Period memory periodAfter = proverManager.getPeriod(periodId);

        assertEq(periodAfter.prover, periodBefore.prover, "Prover was changed");
        assertEq(periodAfter.stake, periodBefore.stake, "Stake was changed");
        assertEq(periodAfter.fee, periodBefore.fee, "Fee was changed");
        assertEq(periodAfter.delayedFeePercentage, periodBefore.delayedFeePercentage, "Delayed fee was changed");
        assertEq(periodAfter.end, vm.getBlockTimestamp() + proverManager.successionDelay(), "End set incorrectly");
        assertEq(periodAfter.deadline, periodAfter.end + proverManager.provingWindow(), "Deadline set incorrectly");
        assertEq(periodAfter.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_bid_shouldDeductLivenessBond() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        uint256 escrowedBefore = _currencyBalance(address(proverManager));
        uint256 balanceBefore = proverManager.balances(proverA);

        vm.prank(proverA);
        proverManager.bid(offer);

        uint256 escrowedAfter = _currencyBalance(address(proverManager));
        uint256 balanceAfter = proverManager.balances(proverA);

        assertEq(escrowedAfter, escrowedBefore, "Value held by ProverManager changed");
        assertEq(balanceAfter, balanceBefore - proverManager.livenessBond(), "Balance not updated correctly");
    }

    function test_CurrentPeriodIsOpen_bid_shouldSetNextPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        period = proverManager.getPeriod(periodId + 1);

        assertEq(period.prover, proverA, "Prover does not match the bidder");
        assertEq(period.stake, proverManager.livenessBond(), "Stake was set incorrectly");
        assertEq(period.fee, offer, "Fee does not match the bid");
        assertEq(period.delayedFeePercentage, proverManager.delayedFeePercentage(), "Delayed fee set incorrectly");
        assertEq(period.end, 0, "New period is closed");
        assertEq(period.deadline, 0, "New period has deadline");
        assertEq(period.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_bid_shouldEmitEvent() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        uint256 bond = proverManager.livenessBond();
        vm.prank(proverA);
        vm.expectEmit();
        emit IProverManager.ProverOffer(proverA, periodId + 1, offer, bond);
        proverManager.bid(offer);
    }

    function test_CurrentPeriodIsOpen_bid_shouldAllowCurrentProverToBid() public {
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());
        address existingProver = period.prover;

        _deposit(existingProver, proverManager.livenessBond());
        vm.prank(existingProver);
        proverManager.bid(offer);

        period = proverManager.getPeriod(periodId + 1);
        assertEq(period.prover, existingProver, "Prover has changed");
    }

    function test_CurrentPeriodIsOpen_bid_shouldAllowZeroBid() public {
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        if (period.fee == 0) {
            // ignore this test if the fee is already zero
            return;
        }

        _deposit(proverA, DEPOSIT_AMOUNT);
        vm.prank(proverA);
        proverManager.bid(0);

        period = proverManager.getPeriod(proverManager.currentPeriodId() + 1);
        assertEq(period.prover, proverA, "Prover does not match bidder");
        assertEq(period.fee, 0, "Period fee is not zero");
    }

    function test_CurrentPeriodIsOpen_bid_shouldRevertIfBidderHasInsufficientBalance() public {
        // Sanity check. This precondition should occur automatically because there is no _deposit call
        assertLe(proverManager.balances(proverA), proverManager.livenessBond(), "Invalid test configuration");

        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        vm.expectRevert();
        proverManager.bid(offer);
    }
}
