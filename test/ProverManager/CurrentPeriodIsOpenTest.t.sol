// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {CurrentPeriodIsActiveTest} from "./CurrentPeriodIsActiveTest.t.sol";

import {LibPercentage} from "src/libs/LibPercentage.sol";
import {LibProvingPeriod} from "src/libs/LibProvingPeriod.sol";
import {BaseProverManager} from "src/protocol/BaseProverManager.sol";

import {MockCheckpointTracker} from "../mocks/MockCheckpointTracker.sol";
import {IInbox} from "src/protocol/IInbox.sol";
import {IProverManager} from "src/protocol/IProverManager.sol";

/// Represents states where the current period has no end timestamp
/// This contract assumes the fee is non-zero, so it can be outbid
abstract contract CurrentPeriodIsOpenTest is CurrentPeriodIsActiveTest {
    function test_CurrentPeriodIsOpen_bid_shouldRevertIfOfferMatchesFee() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());

        vm.prank(proverA);
        vm.expectRevert(BaseProverManager.OfferedFeeTooHigh.selector);
        proverManager.bid(period.fee);
    }

    function test_CurrentPeriodIsOpen_bid_shouldRevertIfOfferInsufficientlyUnderbid() public {
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());

        _deposit(proverA, DEPOSIT_AMOUNT);
        vm.prank(proverA);
        vm.expectRevert(BaseProverManager.OfferedFeeTooHigh.selector);
        proverManager.bid(period.fee - 1);
    }

    function test_CurrentPeriodIsOpen_bid_shouldNotChangeCurrentPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 initialPeriodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(initialPeriodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        assertEq(proverManager.currentPeriodId(), initialPeriodId, "Current period was changed");
    }

    function test_CurrentPeriodIsOpen_bid_shouldCloseCurrentPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);

        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory periodBefore = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(periodBefore.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        LibProvingPeriod.Period memory periodAfter = proverManager.getPeriod(periodId);

        assertEq(periodAfter.prover, periodBefore.prover, "Prover was changed");
        assertEq(periodAfter.stake, periodBefore.stake, "Stake was changed");
        assertEq(periodAfter.fee, periodBefore.fee, "Fee was changed");
        assertEq(periodAfter.delayedFeePercentage, periodBefore.delayedFeePercentage, "Delayed fee was changed");
        assertEq(periodAfter.end, vm.getBlockTimestamp() + proverManager.successionDelay(), "End set incorrectly");
        assertEq(periodAfter.deadline, periodAfter.end + proverManager.provingWindow(), "Deadline set incorrectly");
        assertEq(periodAfter.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_bid_shouldDeductLivenessBond() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        uint256 escrowedBefore = _currencyBalance(address(proverManager));
        uint256 balanceBefore = proverManager.balances(proverA);

        vm.prank(proverA);
        proverManager.bid(offer);

        uint256 escrowedAfter = _currencyBalance(address(proverManager));
        uint256 balanceAfter = proverManager.balances(proverA);

        assertEq(escrowedAfter, escrowedBefore, "Value held by ProverManager changed");
        assertEq(balanceAfter, balanceBefore - proverManager.livenessBond(), "Balance not updated correctly");
    }

    function test_CurrentPeriodIsOpen_bid_shouldSetNextPeriod() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        proverManager.bid(offer);

        period = proverManager.getPeriod(periodId + 1);

        assertEq(period.prover, proverA, "Prover does not match the bidder");
        assertEq(period.stake, proverManager.livenessBond(), "Stake was set incorrectly");
        assertEq(period.fee, offer, "Fee does not match the bid");
        assertEq(period.delayedFeePercentage, proverManager.delayedFeePercentage(), "Delayed fee set incorrectly");
        assertEq(period.end, 0, "New period is closed");
        assertEq(period.deadline, 0, "New period has deadline");
        assertEq(period.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_bid_shouldEmitEvent() public {
        _deposit(proverA, DEPOSIT_AMOUNT);
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        uint256 bond = proverManager.livenessBond();
        vm.prank(proverA);
        vm.expectEmit();
        emit IProverManager.ProverOffer(proverA, periodId + 1, offer, bond);
        proverManager.bid(offer);
    }

    function test_CurrentPeriodIsOpen_bid_shouldAllowCurrentProverToBid() public {
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());
        address existingProver = period.prover;

        _deposit(existingProver, proverManager.livenessBond());
        vm.prank(existingProver);
        proverManager.bid(offer);

        period = proverManager.getPeriod(periodId + 1);
        assertEq(period.prover, existingProver, "Prover has changed");
    }

    function test_CurrentPeriodIsOpen_bid_shouldAllowZeroBid() public {
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());

        _deposit(proverA, DEPOSIT_AMOUNT);
        vm.prank(proverA);
        proverManager.bid(0);

        period = proverManager.getPeriod(proverManager.currentPeriodId() + 1);
        assertEq(period.prover, proverA, "Prover does not match bidder");
        assertEq(period.fee, 0, "Period fee is not zero");
    }

    function test_CurrentPeriodIsOpen_bid_shouldRevertIfBidderHasInsufficientBalance() public {
        // Sanity check. This precondition should occur automatically because there is no _deposit call
        assertLe(proverManager.balances(proverA), proverManager.livenessBond(), "Invalid test configuration");

        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        uint96 offer = LibPercentage.scaleByBPS(period.fee, proverManager.maxBidFraction());

        vm.prank(proverA);
        vm.expectRevert();
        proverManager.bid(offer);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldRevertIfPublicationIsUnknown() public {
        IInbox.PublicationHeader memory header;
        inbox.setHeaderValidity(false);
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.InvalidPublication.selector);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldRevertIfPublicationIsOnLivenessDeadline() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow();
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationNotOldEnough.selector);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldNotRevertIfPublicationIsBeforeLivenessDeadline() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow();
        header.timestamp = header.timestamp - 1;
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationNotOldEnough.selector, 0);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldRevertIfPublicationIsOnPreviousPeriodEnd() public {
        uint256 periodId = proverManager.currentPeriodId();
        IInbox.PublicationHeader memory header;
        header.timestamp = periodId > 0 ? proverManager.getPeriod(periodId - 1).end : 0;
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationBeforeCurrentPeriod.selector);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldNotRevertIfPublicationIsOnPeriodStart() public {
        uint256 periodId = proverManager.currentPeriodId();
        IInbox.PublicationHeader memory header;
        header.timestamp = periodId > 0 ? proverManager.getPeriod(periodId - 1).end : 0;
        header.timestamp = header.timestamp + 1;
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationBeforeCurrentPeriod.selector, 0);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldRevertIfPublicationIsProven() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID();
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationAlreadyProven.selector);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldNotRevertIfPublicationIsNotProven() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID() + 1;
        vm.prank(evictor);
        vm.expectRevert(BaseProverManager.PublicationAlreadyProven.selector, 0);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldClosePeriod() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID() + 1;

        vm.prank(evictor);
        proverManager.evictProver(header);
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());

        assertEq(period.end, vm.getBlockTimestamp() + proverManager.exitDelay(), "End timestamp was set incorrectly");
        assertEq(period.deadline, period.end, "Deadline does not match end timestamp");
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldTransferEvictorIncentive() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID() + 1;
        uint256 periodId = proverManager.currentPeriodId();

        LibProvingPeriod.Period memory periodBefore = proverManager.getPeriod(periodId);
        address prover = periodBefore.prover;
        uint96 incentive = LibPercentage.scaleByBPS(periodBefore.stake, proverManager.evictorIncentiveFraction());
        uint256 escrowedBefore = _currencyBalance(address(proverManager));
        uint256 proverBalanceBefore = proverManager.balances(prover);
        uint256 evictorBalanceBefore = proverManager.balances(evictor);

        vm.prank(evictor);
        proverManager.evictProver(header);

        LibProvingPeriod.Period memory periodAfter = proverManager.getPeriod(periodId);
        uint256 escrowedAfter = _currencyBalance(address(proverManager));
        uint256 proverBalanceAfter = proverManager.balances(prover);
        uint256 evictorBalanceAfter = proverManager.balances(evictor);

        assertEq(escrowedAfter, escrowedBefore, "Value held by ProverManager changed");
        assertEq(proverBalanceAfter, proverBalanceBefore, "Balance held by prover changed");
        assertEq(evictorBalanceAfter, evictorBalanceBefore + incentive, "Evictor balance set incorrectly");
        assertEq(periodAfter.stake, periodBefore.stake - incentive, "Period stake deducted incorrectly");
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldLeaveOtherFieldsUnchanged() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID() + 1;

        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory periodBefore = proverManager.getPeriod(periodId);
        vm.prank(evictor);
        proverManager.evictProver(header);
        LibProvingPeriod.Period memory periodAfter = proverManager.getPeriod(periodId);

        assertEq(periodBefore.prover, periodAfter.prover, "Prover changed");
        assertEq(periodBefore.fee, periodAfter.fee, "Fee changed");
        assertEq(periodBefore.delayedFeePercentage, periodAfter.delayedFeePercentage, "Delayed fee changed");
        assertEq(periodBefore.pastDeadline, false, "Period already had missed deadline");
        assertEq(periodAfter.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_evictProver_shouldEmitEvent() public {
        IInbox.PublicationHeader memory header;
        header.timestamp = vm.getBlockTimestamp() - proverManager.livenessWindow() - 1;
        header.id = checkpointTracker.LAST_PROVEN_ID() + 1;
        LibProvingPeriod.Period memory period = proverManager.getPeriod(proverManager.currentPeriodId());
        uint256 end = vm.getBlockTimestamp() + proverManager.exitDelay();

        vm.prank(evictor);
        vm.expectEmit();
        emit IProverManager.ProverEvicted(period.prover, evictor, end, period.stake);
        proverManager.evictProver(header);
    }

    function test_CurrentPeriodIsOpen_exit_shouldRevertIfNotCalledByProver() public {
        vm.expectRevert(BaseProverManager.OnlyCurrentProver.selector);
        vm.prank(evictor);
        proverManager.exit();
    }

    function test_CurrentPeriodIsOpen_exit_shouldClosePeriod() public {
        uint256 periodId = proverManager.currentPeriodId();
        address prover = proverManager.getPeriod(periodId).prover;

        vm.prank(prover);
        proverManager.exit();
        LibProvingPeriod.Period memory period = proverManager.getPeriod(periodId);

        assertEq(period.end, vm.getBlockTimestamp() + proverManager.exitDelay(), "End timestamp was set incorrectly");
        assertEq(period.deadline, period.end + proverManager.provingWindow(), "Deadline was set incorrectly");
    }

    function test_CurrentPeriodIsOpen_exit_shouldLeaveOtherFieldsUnchanged() public {
        uint256 periodId = proverManager.currentPeriodId();
        LibProvingPeriod.Period memory periodBefore = proverManager.getPeriod(periodId);
        vm.prank(periodBefore.prover);
        proverManager.exit();
        LibProvingPeriod.Period memory periodAfter = proverManager.getPeriod(periodId);

        assertEq(periodBefore.prover, periodAfter.prover, "Prover changed");
        assertEq(periodBefore.stake, periodAfter.stake, "Stake changed");
        assertEq(periodBefore.fee, periodAfter.fee, "Fee changed");
        assertEq(periodBefore.delayedFeePercentage, periodAfter.delayedFeePercentage, "Delayed fee changed");
        assertEq(periodBefore.pastDeadline, false, "Period already had missed deadline");
        assertEq(periodAfter.pastDeadline, false, "Period has missed deadline");
    }

    function test_CurrentPeriodIsOpen_exit_shouldEmitEvent() public {
        uint256 periodId = proverManager.currentPeriodId();
        address prover = proverManager.getPeriod(periodId).prover;
        uint256 end = vm.getBlockTimestamp() + proverManager.exitDelay();
        uint256 deadline = end + proverManager.provingWindow();

        vm.prank(prover);
        vm.expectEmit();
        emit IProverManager.ProverExited(prover, end, deadline);
        proverManager.exit();
    }
}
